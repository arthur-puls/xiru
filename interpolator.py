# interpolator for 1D LTE models
# Please use "kurucz_extractor.py" to download the models in the format accepted by this module
import numpy as np
from scipy.interpolate import interp1d, interp2d, LinearNDInterpolator, NearestNDInterpolator

# === USER OPTIONS AREA ===

# folder where the model grid is located
global gridpath; gridpath = '/path/to/atmospheric/models/' # do not forget the "/" at the end!

# valid options are 'KURUCZ' or 'KURTYPE'. Defaults to KURUCZ if the kurucz_extractor routine has been used.
global format_type; format_type = 'KURUCZ'

# metalist contains file names for the grid. You can change them according to your convenience.
# metalval contains the metallicity values in the grid. Must correspond to metalist.
# these lists MUST correspond to the files contained in the 'gridpath' folder
# default values correspond to the files generated by the kurucz_extractor routine
global metalist; metalist = ['am40','am25','am20','am15','am10','am05','ap00','ap02','ap05']
global metalval; metalval = np.array([-4.0, -2.5, -2.0, -1.5, -1.0, -0.5,  0.0,  0.2,  0.5])

# === END OF USER OPTIONS AREA ===

def pick_model_name(metal):
    'Sorts models by metallicity'
    'Returns the filenames of the two metallicity nearest neighbours in the grid.'
    if metal in metalval:
        fin = metalist[np.argmin(abs(metal-metalval))]
        return fin, None
    elif np.amin(metalval) < metal and metal < np.amax(metalval):
        dif = metal-metalval
        for i in range(1,dif.shape[0]):
            if dif[i] < 0 and dif[i-1] > 0:
                idx1 = i-1
                idx2 = i
                break
        return metalist[idx1], metalist[idx2]
    else:
        print('Interpolator: INVALID METALLICITY! [M/H] = %.2f' % metal)
        raise SystemExit()

def check_teff_logg(teff, logg, t, g):
    "Checks if Teff and logg are in the interpolation limits."
    if teff < t.min() or teff > t.max():
        print('Interpolator: INVALID TEFF! Teff = %4i' % teff)
        raise SystemExit()
    elif logg < g.min() or logg > g.max():
        print('Interpolator: INVALID LOGG! logg = %.3f' % logg)
        raise SystemExit()
    else:
        return

def create_par_lists(t):
    tefflist = []; logglist = []
    for i in range(len(t)):
        if 'MODEL' in t[i]:
            tefflist.append(float(t[i+1].split()[0]))
            logglist.append(float(t[i+1].split()[1]))
    tefflist = np.asarray(tefflist); logglist = np.asarray(logglist)
    return tefflist, logglist

def copy_model(teff, logg, metal, fin):
    "Just copies a model in case all four input atmospheric parameters are in the grid."
    f = open('%s%s' % (gridpath,fin), 'r')
    t = f.readlines()
    f.close()
    tefflist, logglist = create_par_lists(t)
    check_teff_logg(teff, logg, tefflist, logglist)
    for i in range(len(t)):
        if 'MODEL' in t[i] and float(t[i+1].split()[0]) == teff and float(t[i+1].split()[1]) == logg:
            ntau = int(t[i].split()[1])
            idx0 = i+2
            idx1 = i+2+ntau
            break
    mod = t[idx0:idx1]
    model = mod_l2a(mod, ntau, len(mod[0].split()))
    return model

def load_some_model(teff, logg, t):
    "Returns 2D np array"
    for i in range(len(t)):
        if 'MODEL' in t[i] and float(t[i+1].split()[0]) == teff and float(t[i+1].split()[1]) == logg:
            ntau = int(t[i].split()[1])
            idx0 = i+2
            idx1 = i+2+ntau
            break
    mod = t[idx0:idx1]
    model = mod_l2a(mod, ntau, len(mod[0].split()))
    return model

def mod_l2a(m, nlines, ncols):
    model = np.zeros((nlines,ncols))
    for i in range(nlines):
        for j in range(ncols):
            model[i,j] = float(m[i].split()[j])
    return model

def make_footer(metal, micro):
    "Prepares model footer for MOOG input"
    s = []
    s.append('%13.4f\n' % micro)
    s.append('NATOMS        0%15.2f\n' % metal)
    s.append('NMOL          0\n')
    return s

def make_header(teff, logg, metal, micro, ntau):
    "Prepares model header for MOOG input"
    s = []
    s.append('%s\n' % format_type)
    s.append('%6.f./%6.1f/%7.1f      mic = %6.4f\n' % (teff, logg, metal, micro))
    s.append('%15s\n' % str(ntau))
    # the reference wavelength used by MOOG if model is KURTYPE
    if format_type == 'KURTYPE':
        s.append('5000.0\n')
    return s

def get2models(p, l, t, p2, fp):
    if fp == 'logg':
        k = 0; h = 1;
    else:
        k = 1; h = 0
    dif = p-l
    for i in range(1,dif.shape[0]):
        if dif[i] < 0 and dif[i-1] > 0:
            idxt1 = i-1
            idxt2 = i
            break
    for i in range(len(t)):
        if 'MODEL' in t[i] and float(t[i+1].split()[k]) == l[idxt1] and float(t[i+1].split()[h]) == p2:
            ntau = int(t[i].split()[1])
            idx0 = i+2
            idx1 = i+2+ntau
            break
    m1 = t[idx0:idx1]
    model1 = mod_l2a(m1, ntau, len(m1[0].split()))
    for i in range(len(t)):
        if 'MODEL' in t[i] and float(t[i+1].split()[k]) == l[idxt2] and float(t[i+1].split()[h]) == p2:
            ntau = int(t[i].split()[1])
            idx0 = i+2
            idx1 = i+2+ntau
            break
    m2 = t[idx0:idx1]
    model2 = mod_l2a(m2, ntau, len(m2[0].split()))
    return model1, model2, l[idxt1], l[idxt2]

def get4models(teff, logg, metal, mod1, mod2, fp):
    # 2----4
    # |  0 |
    # 1----3
    if fp != 'm':
        dif = metal-metalval
        for i in range(1,dif.shape[0]):
            if dif[i] < 0 and dif[i-1] > 0:
                idx1 = i-1
                idx2 = i
                break
        y1 = metalval[idx1]; y2 = metalval[idx2]
        y3 = metalval[idx1]; y4 = metalval[idx2]
    if fp == 'teff':
        f = open('%s%s' % (gridpath,mod1), 'r'); t = f.readlines(); f.close()
        tefflist, logglist = create_par_lists(t); check_teff_logg(teff, logg, tefflist, logglist)
        m1, m3, x1, x3 = get2models(logg, logglist, t, teff, fp)
        f = open('%s%s' % (gridpath,mod2), 'r'); t = f.readlines(); f.close()
        tefflist, logglist = create_par_lists(t); check_teff_logg(teff, logg, tefflist, logglist)
        m2, m4, x2, x4 = get2models(logg, logglist, t, teff, fp)
    elif fp == 'logg':
        f = open('%s%s' % (gridpath,mod1), 'r'); t = f.readlines(); f.close()
        tefflist, logglist = create_par_lists(t); check_teff_logg(teff, logg, tefflist, logglist)
        m1, m3, x1, x3 = get2models(teff, tefflist, t, logg, fp)
        f = open('%s%s' % (gridpath,mod2), 'r'); t = f.readlines(); f.close()
        tefflist, logglist = create_par_lists(t); check_teff_logg(teff, logg, tefflist, logglist)
        m2, m4, x2, x4 = get2models(teff, tefflist, t, logg, fp)
    else:
        f = open('%s%s' % (gridpath,mod1), 'r'); t = f.readlines(); f.close()
        tefflist, logglist = create_par_lists(t); check_teff_logg(teff, logg, tefflist, logglist)
        dift = teff - tefflist; difg = logg - logglist
        for i in range(1,dift.shape[0]):
            if dift[i] < 0 and dift[i-1] > 0:
                idx1 = i-1
                idx2 = i
                break
        for i in range(1,difg.shape[0]):
            if difg[i] < 0 and difg[i-1] > 0:
                idy1 = i-1
                idy2 = i
                break
        x1 = tefflist[idx1]; x2 = tefflist[idx1]; x3 = tefflist[idx2]; x4 = tefflist[idx2]
        y1 = logglist[idy1]; y2 = logglist[idy2]; y3 = logglist[idy1]; y4 = logglist[idy2]
        ml = []
        xl = [x1, x2, x3, x4]; yl = [y1,y2,y3,y4]
        for i in range(4):
            ml.append(copy_model(xl[i], yl[i], metal, mod1))
        m1 = ml[0]; m2 = ml[1]; m3 = ml[2]; m4 = ml[3]
    x = np.array([x1,x2,x3,x4])
    y = np.array([y1,y2,y3,y4])
    m = [m1,m2,m3,m4]
    return x, y, m

def i1d(teff, logg, metal, mod1, mod2):
    # 1d linear interpolation
    f = open('%s%s' % (gridpath,mod1), 'r')
    t = f.readlines()
    f.close()
    tefflist, logglist = create_par_lists(t)
    check_teff_logg(teff, logg, tefflist, logglist)
    if teff not in tefflist:
        # interpolate in teff
        x0 = teff
        m1, m2, x1, x2 = get2models(teff, tefflist, t, logg, 'logg')
    elif logg not in logglist:
        # interpolate in logg
        x0 = logg
        m1, m2, x1, x2 = get2models(logg, logglist, t, teff, 'teff')
    else:
        # interpolate in metal
        x0 = metal
        dif = metal-metalval
        for i in range(1,dif.shape[0]):
            if dif[i] < 0 and dif[i-1] > 0:
                idx1 = i-1
                idx2 = i
                break
        x1 = metalval[idx1]; x2 = metalval[idx2]
        m1 = copy_model(teff, logg, metal, mod1)
        m2 = copy_model(teff, logg, metal, mod2)
    im = np.zeros(m1.shape) # m2.shape supposed to be the same
    x = np.array([x1,x2])
    for i in range(im.shape[1]):
        y = np.array([m1[:,i],m2[:,i]])
        z = interp1d(x, y, axis=0)
        im[:,i] = z(x0)
    return im

def i2d(teff, logg, metal, mod1, mod2, trueidx):
    # 2d linear interpolation
    if trueidx == 0:
        # teff in grid
        x, y, m = get4models(teff, logg, metal, mod1, mod2, 'teff')
        x0 = logg; y0 = metal
    elif trueidx == 1:
        # logg in grid
        x, y, m = get4models(teff, logg, metal, mod1, mod2, 'logg')
        x0 = teff; y0 = metal
    else:
        # metal in grid
        x, y, m = get4models(teff, logg, metal, mod1, mod2, 'm')
        x0 = teff; y0 = logg
    im = np.zeros(m[0].shape)
    for i in range(im.shape[1]): # i -> model column
        for k in range(im.shape[0]): # k -> model line
            z = np.zeros(4)
            for j in range(4): # j -> m list id (m1, m2, m3 or m4 from get4models)
                z[j] = m[j][k,i]
            i2 = interp2d(x, y, z)
            im[k,i] = i2(x0, y0)
    return im

def i3d(teff, logg, metal, mod1, mod2):
    # 3d interpolation
    # xi -> teff; yi -> logg; zi -> metal
    whichinterp = 'linear' # nearest or linear -- linear seems to give better results
    f = open('%s%s' % (gridpath,mod1), 'r'); t1 = f.readlines(); f.close()
    tefflist, logglist = create_par_lists(t1); check_teff_logg(teff, logg, tefflist, logglist)
    x = find_param(teff, tefflist)
    y = find_param(logg, logglist)
    z = find_metal(metal)
    f = open('%s%s' % (gridpath,mod2), 'r'); t2 = f.readlines(); f.close()
    # I am assuming x and y will be the same here
    t = [t1,t2]
    m = []
    #x8 = []; y8 = []; z8 = []
    points = np.zeros((8,3))
    l = 0
    for i in range(len(x)):
        for j in range(len(y)):
            for k in range(len(t)):
                points[l,:] = [x[i], y[j], z[k]]; l=l+1
                m.append(load_some_model(x[i],y[j],t[k]))
    # LinearNDInterpolator
    model = np.zeros(m[0].shape)
    for i in range(model.shape[0]):
        for j in range(model.shape[1]):
            values = np.zeros(8)
            for k in range(8):
                values[k] = m[k][i,j]
            if whichinterp == 'linear':
                i3 = LinearNDInterpolator(points, values, rescale=True)
            else:
                i3 = NearestNDInterpolator(points, values, rescale=True)
            model[i,j] = i3(teff, logg, metal)
    return model

def find_metal(metal):
    dif = metal-metalval
    for i in range(1,dif.shape[0]):
        if dif[i] < 0 and dif[i-1] > 0:
            idx1 = i-1
            idx2 = i
            break
    y1 = metalval[idx1]; y2 = metalval[idx2]
    return y1, y2

def find_param(par, parlist):
    dif = par-parlist
    for i in range(1,dif.shape[0]):
        if dif[i] < 0 and dif[i-1] > 0:
            idx1 = i-1
            idx2 = i
            break
    x1 = parlist[idx1]; x2 = parlist[idx2]
    return x1, x2

def create_model(teff, logg, metal, micro):
    # creates and exports model w/o header and footer
    # useful for being used by modules that do not require an ascii file model
    tstep = 250.; gstep = 0.5
    mod1, mod2 = pick_model_name(metal)
    check = np.array([teff % tstep == 0, logg % gstep == 0, mod2==None])
    nfalse = np.size(check) - np.count_nonzero(check)
    if check.all() == True:
        # model is in the grid...just copy it
        model = copy_model(teff, logg, metal, mod1)
    elif nfalse == 1:
        # 1d interpolation -- 2 points in the grid
        model = i1d(teff, logg, metal, mod1, mod2)
    elif nfalse == 2:
        # 2d interpolation -- 1 point in the grid
        for i in range(check.shape[0]):
            if check[i] == True:
                trueidx = i
                break
        model = i2d(teff, logg, metal, mod1, mod2, trueidx)
    else:
        # full 3d interpolation
        model = i3d(teff, logg, metal, mod1, mod2)
    return model

def run_interpolator(atmpar, tstep=250., gstep=0.5):
    "Manages model interpolation from the input atmospheric parameters and saves it to a text file"
    "atmpar is a list or numpy array with the input atmospheric parameters [Teff, logg, metal, micro]"
    "tstep is the delta Teff in K in model grid"
    "gstep is the delta logg in dex in model grid"
    teff = atmpar[0]
    logg = atmpar[1]
    metal = atmpar[2]
    micro = atmpar[3]
    mod1, mod2 = pick_model_name(metal)
    # the following line only works if minimum Teff in grid % tstep = 0 and minimum logg in grid % gstep = 0
    # For instance, it works with default tstep value (250) if the lower Teff value in the grid is 1000 or 3500, but fails if the value is, e.g., 4248
    # If you really need such unorthodox configuration, add some offset value so that min grid Teff % tstep = 0 and/or min grid logg % gstep = 0
    check = np.array([teff % tstep == 0, logg % gstep == 0, mod2==None])
    nfalse = np.size(check) - np.count_nonzero(check)
    if check.all() == True:
        # model is in the grid...just copy it
        model = copy_model(teff, logg, metal, mod1)
    elif nfalse == 1:
        # 1d interpolation -- 2 points in the grid
        model = i1d(teff, logg, metal, mod1, mod2)
    elif nfalse == 2:
        # 2d interpolation -- 1 point in the grid
        for i in range(check.shape[0]):
            if check[i] == True:
                trueidx = i
                break
        model = i2d(teff, logg, metal, mod1, mod2, trueidx)
    else:
        # full 3d interpolation
        model = i3d(teff, logg, metal, mod1, mod2)
    strh = make_header(teff, logg, metal, micro, model.shape[0])
    strf = make_footer(metal, micro)
    f = open('MODEL', 'w')
    for i in range(len(strh)):
        f.write('%s' % strh[i])
    for i in range(model.shape[0]):
        if format_type == 'KURTYPE':
            f.write('%15.8E%9.1f%10.3E%10.3E\n' % (model[i,0],model[i,1],model[i,2],model[i,3]))
        elif format_type == 'KURUCZ':
            f.write('%15.8E%9.1f%10.3E%10.3E%10.3E%10.3E%10.3E\n' % (model[i,0],model[i,1],model[i,2],model[i,3],model[i,4],model[i,5],model[i,6]))
        else:
            print('Invalid model type!')
            raise SystemExit()
    for i in range(len(strf)):
        f.write('%s' % strf[i])
    f.close()

if __name__ == "__main__":
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument('atmparam', help='Atmospheric parameters: Teff logg [M/H] micro', nargs='+', type=float)
    args = parser.parse_args()
    if len(args.atmparam) == 4:
        run_interpolator(args.atmparam)
    else:
        print('Wrong number of parameters!')